// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

var types = require('azure-mobile-apps.core/utilities/types'),
    _ = require('underscore.string'),
    parseOData = require('azure-mobile-apps.query/parseOData'),
    ExpressionVisitor = require('azure-mobile-apps.query/ExpressionVisitor'),
    convertTypes = require('./convertTypes'),
    booleanize = require('./booleanize'),
    helpers = require('../helpers'),
    expressions = require('azure-mobile-apps.query/expressions');

module.exports = function (query, tableConfig) {
    var formatter = new SqlFormatter(tableConfig);
    formatter.format(query);
    return {
        sql: formatter.sql,
        parameters: formatter.parameters
    };
};

function ctor(tableConfig) {
    this.tableConfig = tableConfig || {};
    this.schemaName = this.tableConfig.schemaName || 'dbo';
}

var SqlFormatter = types.deriveClass(ExpressionVisitor, ctor, {
    format: function (query) {
        this.sql = '';
        this.paramNumber = 0;
        this.parameters = [];

        // if a skip is requested but no top is defined, we need
        // to still generate the paging query, so default top to
        // max. Really when doing paging, the user should also be
        // specifying a top explicitly however.
        if (query.skip > 0 && query.take === undefined) {
            query.take = 9007199254740992; // Number.MAX_SAFE_INTEGER + 1; // ES6
        }

        if (query.skip >= 0 && query.take >= 0) {
            this.sql = this._formatPagedQuery(query);
        } else {
            this.sql = this._formatQuery(query);
        }

        this.sql = this.sql.trim();
    },

    _formatQuery: function (query) {
        var formattedSql;

        var selection = query.selections ? this._formatSelection(query.selections, query.systemProperties) : '*';

        // set the top clause to be the minimumn of the top
        // and result limit values if either has been set.
        var take = '';
        var limit = -1;
        var resultLimit = query.resultLimit || Number.MAX_VALUE;
        if (query.take >= 0) {
            limit = Math.min(resultLimit, query.take);
        }
        else if (resultLimit != Number.MAX_VALUE) {
            limit = query.resultLimit;
        }
        if (limit != -1) {
            take = 'TOP ' + limit.toString() + ' ';
        }

        var filter = this._formatFilter(query);
        var ordering = this._formatOrderBy(query);

        var tableName = helpers.formatTableName(this.schemaName, query.table);
        formattedSql = _.sprintf("SELECT %s%s FROM %s", take, selection, tableName);
        if (filter.length > 0) {
            formattedSql += ' WHERE ' + filter;
        }
        if (ordering.length > 0) {
            formattedSql += ' ORDER BY ' + ordering;
        }

        if (query.inlineCount === 'allpages') {
            formattedSql += '; ' + this._formatCountQuery(tableName, query);
        }

        return formattedSql;
    },

    _formatPagedQuery: function (query) {
        var formattedSql, selection = '',
            aliasedSelection = '';

        if (query.selections) {
            selection = this._formatSelection(query.selections, query.systemProperties);
            aliasedSelection = '[t1].[ROW_NUMBER], ' + this._formatSelection(query.selections, query.systemProperties, '[t1].');
        }
        else {
            selection = aliasedSelection = "*";
        }

        var filter = this._formatFilter(query, '(1 = 1)');
        var ordering = this._formatOrderBy(query, '[id]');

        // Plug all the pieces into the template to get the paging sql
        var tableName = helpers.formatTableName(this.schemaName, query.table);
        formattedSql = _.sprintf(
            "SELECT %s FROM (SELECT ROW_NUMBER() OVER (ORDER BY %s) AS [ROW_NUMBER], %s " +
            "FROM %s WHERE %s) AS [t1] " +
            "WHERE [t1].[ROW_NUMBER] BETWEEN %d + 1 AND %d + %d " +
            "ORDER BY [t1].[ROW_NUMBER]",
            aliasedSelection, ordering, selection, tableName, filter, query.skip, query.skip, query.take);

        if (query.inlineCount === 'allpages') {
            formattedSql += '; ' + this._formatCountQuery(tableName, query);
        }

        return formattedSql;
    },

    _formatCountQuery: function (table, query) {
        var filter;

        if (query.filters || query.id !== undefined || this.tableConfig.supportsSoftDelete) {
            this.sql = '';
            filter = this._formatFilter(query);
        }

        var sql = 'SELECT COUNT(*) AS [count] FROM ' + table;
        if (filter) {
            sql += ' WHERE ' + filter;
        }
        return sql;
    },

    _formatOrderBy: function (query, defaultOrder) {
        if (!query.ordering) {
            return defaultOrder || '';
        }

        var orderings = parseOData.orderBy(query.ordering),
            order = '',
            self = this;

        orderings.forEach(function (ordering) {
            if (order.length > 0) {
                order += ', ';
            }
            self.sql = '';
            self.visit(ordering.selector);
            if (!ordering.ascending) {
                self.sql += ' DESC';
            }
            order += self.sql;
        });

        return order;
    },

    _formatSelection: function (selection, systemProperties, prefix) {
        systemProperties = (systemProperties || []).map(systemPropertyToColumnName);

        var formattedSelection = '',
            columns = selection.split(',').concat(systemProperties);

        columns.forEach(function (column) {
            var member = column.trim();
            if (formattedSelection.length > 0) {
                formattedSelection += ', ';
            }
            formattedSelection += (prefix || '') + helpers.formatMember(member);
        });

        return formattedSelection;
    },

    _formatFilter: function (query, defaultFilter) {
        // if we already have a parsed filter use it,
        // otherwise parse the filter
        var filterExpr;
        if (query.filters && query.filters.length > 0) {
            filterExpr = parseOData(query.filters);
        }

        if (query.id !== undefined) {
            var id = this.tableConfig.hasStringId ? "'" + query.id.replace(/'/g, "''") + "'" : query.id;
            var idFilterExpr = parseOData(_.sprintf('(id eq %s)', id));

            // append the id filter to any existing filter
            if (filterExpr) {
                filterExpr = new expressions.Binary(filterExpr, idFilterExpr, 'And');
            }
            else {
                filterExpr = idFilterExpr;
            }
        }

        // if soft delete is enabled filter out deleted records
        if (this.tableConfig.supportsSoftDelete && !query.includeDeleted) {
            var deletedFilter = parseOData(_.sprintf('(__deleted eq false)'));
            if (filterExpr) {
                filterExpr = new expressions.Binary(filterExpr, deletedFilter, 'And');
            }
            else {
                filterExpr = deletedFilter;
            }
        }

        if (!filterExpr) {
            return defaultFilter || '';
        }

        this.sql = '';
        filterExpr = this._finalizeExpression(filterExpr);
        this.visit(filterExpr);

        return this.sql;
    },

    // run the final query translation pipeline on the specified
    // expression, modifying the expression tree as needed
    _finalizeExpression: function (expr) {
        expr = booleanize(expr);
        expr = convertTypes(expr, this.tableConfig);
        return expr;
    },

    visitBinary: function (expr) {
        this.sql += '(';

        var left = null;
        var right = null;

        // modulo requires the dividend to be an integer, monetary or numeric
        // rewrite the expression to convert to numeric, allowing the DB to apply
        // rounding if needed. our default data type for number is float which
        // is incompatible with modulo.
        if (expr.expressionType == 'Modulo') {
            expr.left = new expressions.Convert('numeric', expr.left);
        }

        if (expr.left) {
            left = this.visit(expr.left);
        }

        if (expr.right && (expr.right.value === null)) {
            // inequality expressions against a null literal have a special
            // translation in SQL
            if (expr.expressionType == 'Equal') {
                this.sql += ' IS NULL';
            }
            else if (expr.expressionType == 'NotEqual') {
                this.sql += ' IS NOT NULL';
            }
        }
        else {
            switch (expr.expressionType) {
                case 'Equal':
                    this.sql += ' = ';
                    break;
                case 'NotEqual':
                    this.sql += ' != ';
                    break;
                case 'LessThan':
                    this.sql += ' < ';
                    break;
                case 'LessThanOrEqual':
                    this.sql += ' <= ';
                    break;
                case 'GreaterThan':
                    this.sql += ' > ';
                    break;
                case 'GreaterThanOrEqual':
                    this.sql += ' >= ';
                    break;
                case 'And':
                    this.sql += ' AND ';
                    break;
                case 'Or':
                    this.sql += ' OR ';
                    break;
                case 'Add':
                    this.sql += ' + ';
                    break;
                case 'Subtract':
                    this.sql += ' - ';
                    break;
                case 'Multiply':
                    this.sql += ' * ';
                    break;
                case 'Divide':
                    this.sql += ' / ';
                    break;
                case 'Modulo':
                    this.sql += ' % ';
                    break;
            }

            if (expr.right) {
                right = this.visit(expr.right);
            }
        }

        this.sql += ')';

        if ((left !== expr.left) || (right !== expr.right)) {
            return new expressions.Binary(left, right);
        }

        return expr;
    },

    visitConstant: function (expr) {
        if (expr.value === null) {
            this.sql += 'NULL';
            return expr;
        }

        this.sql += this._createParameter(expr.value);

        return expr;
    },

    _createParameter: function (value) {
        var parameter = {
            name: '@p' + (this.paramNumber++).toString(),
            pos: this.paramNumber,
            value: value
        };

        this.parameters.push(parameter);

        return '@p' + this.paramNumber.toString();
    },

    visitMember: function (expr) {
        if (typeof expr.member === 'string') {
            this.sql += helpers.formatMember(expr.member);
        }
        else {
            this._formatMappedMember(expr);
        }

        return expr;
    },

    visitUnary: function (expr) {
        if (expr.expressionType == 'Not') {
            this.sql += 'NOT ';
            this.visit(expr.operand);
        }
        else if (expr.expressionType == 'Convert') {
            this.sql += _.sprintf("CONVERT(%s, ", expr.desiredType);
            this.visit(expr.operand);
            this.sql += ')';
        }

        return expr;
    },

    visitFunction: function (expr) {
        if (expr.memberInfo) {
            this._formatMappedFunction(expr);
        }
        return expr;
    },

    _formatMappedFunction: function (expr) {
        if (expr.memberInfo.type == 'string') {
            this._formatMappedStringMember(expr.instance, expr.memberInfo, expr.args);
        }
        else if (expr.memberInfo.type == 'date') {
            this._formatMappedDateMember(expr.instance, expr.memberInfo, expr.args);
        }
        else if (expr.memberInfo.type == 'math') {
            this._formatMappedMathMember(expr.instance, expr.memberInfo, expr.args);
        }
    },

    _formatMappedMember: function (expr) {
        if (expr.member.type == 'string') {
            this._formatMappedStringMember(expr.instance, expr.member, null);
        }
    },

    _formatMappedDateMember: function (instance, mappedMemberInfo, args) {
        var functionName = mappedMemberInfo.memberName;

        if (functionName == 'day') {
            this.sql += 'DAY(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'month') {
            this.sql += 'MONTH(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'year') {
            this.sql += 'YEAR(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'hour') {
            this.sql += 'DATEPART(HOUR, ';
            this.visit(instance);
            this.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'minute') {
            this.sql += 'DATEPART(MINUTE, ';
            this.visit(instance);
            this.sql += ')';
        }
        else if (mappedMemberInfo.memberName == 'second') {
            this.sql += 'DATEPART(SECOND, ';
            this.visit(instance);
            this.sql += ')';
        }
    },

    _formatMappedMathMember: function (instance, mappedMemberInfo, args) {
        var functionName = mappedMemberInfo.memberName;

        if (functionName == 'floor') {
            this.sql += 'FLOOR(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (functionName == 'ceiling') {
            this.sql += 'CEILING(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (functionName == 'round') {
            // Use the 'away from zero' midpoint rounding strategy - when
            // a number is halfway between two others, it is rounded toward
            // the nearest number that is away from zero.
            this.sql += 'ROUND(';
            this.visit(instance);
            this.sql += ', 0)';
        }
    },

    _formatMappedStringMember: function (instance, mappedMemberInfo, args) {
        var functionName = mappedMemberInfo.memberName;

        if (functionName == 'substringof') {
            this.sql += '(';
            this.visit(instance);

            this.sql += ' LIKE ';

            // form '%' + <arg> + '%'
            this.sql += "('%' + ";
            this.visit(args[0]);
            this.sql += " + '%')";

            this.sql += ')';
        }
        else if (functionName == 'startswith') {
            this.sql += '(';
            this.visit(instance);

            this.sql += ' LIKE ';

            // form '<arg> + '%'
            this.sql += '(';
            this.visit(args[0]);
            this.sql += " + '%')";

            this.sql += ')';
        }
        else if (functionName == 'endswith') {
            this.sql += '(';
            this.visit(instance);

            this.sql += ' LIKE ';

            // form '%' + '<arg>
            this.sql += "('%' + ";
            this.visit(args[0]);
            this.sql += ')';

            this.sql += ')';
        }
        else if (functionName == 'concat') {
            // Rewrite as an string addition with appropriate conversions.
            // Note: due to sql operator precidence, we only need to inject a
            // single conversion - the other will be upcast to string.
            if (!isConstantOfType(args[0], 'string')) {
                args[0] = new expressions.Convert(helpers.getSqlType(''), args[0]);
            } else if (!isConstantOfType(args[1], 'string')) {
                args[1] = new expressions.Convert(helpers.getSqlType(''), args[1]);
            }
            var concat = new expressions.Binary(args[0], args[1], 'Add');
            this.visit(concat);
        }
        else if (functionName == 'tolower') {
            this.sql += 'LOWER(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (functionName == 'toupper') {
            this.sql += 'UPPER(';
            this.visit(instance);
            this.sql += ')';
        }
        else if (functionName == 'length') {
            // special translation since SQL LEN function doesn't
            // preserve trailing spaces
            this.sql += '(LEN(';
            this.visit(instance);
            this.sql += " + 'X') - 1)";
        }
        else if (functionName == 'trim') {
            this.sql += 'LTRIM(RTRIM(';
            this.visit(instance);
            this.sql += '))';
        }
        else if (functionName == 'indexof') {
            this.sql += "(PATINDEX('%' + ";
            this.visit(args[0]);
            this.sql += " + '%', ";
            this.visit(instance);
            this.sql += ') - 1)';
        }
        else if (functionName == 'replace') {
            this.sql += "REPLACE(";
            this.visit(instance);
            this.sql += ", ";
            this.visit(args[0]);
            this.sql += ", ";
            this.visit(args[1]);
            this.sql += ')';
        }
        else if (functionName == 'substring') {
            this.sql += 'SUBSTRING(';
            this.visit(instance);

            this.sql += ", ";
            this.visit(args[0]);
            this.sql += " + 1, ";  // need to add 1 since SQL is 1 based, but OData is zero based

            if (args.length == 1) {
                // Overload not taking an explicit length. The
                // LEN of the entire expression is used in this case
                // which means everything after the start index will
                // be taken.
                this.sql += 'LEN(';
                this.visit(instance);
                this.sql += ')';
            }
            else if (args.length == 2) {
                // overload taking a length
                this.visit(args[1]);
            }

            this.sql += ')';
        }
    }
});

function isConstantOfType(expr, type) {
    return (expr.expressionType == 'Constant') && (typeof expr.value === type);
}

function systemPropertyToColumnName(propertyName) {
    return '__' + propertyName;
}
